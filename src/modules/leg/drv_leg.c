/*
 * Copyright (c) 2006-2023, RT-Thread Development Team
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Change Logs:
 * Date           Author        Notes
 * 2023-11-01     ChuShicheng   first version
 */
#include "drv_leg.h"
#include "rm_algorithm.h"
#include "rm_module.h"

#include <stdio.h>

#define LEFT 0
#define RIGHT 1
static uint8_t idx = 0; // register idx,是该文件的全局轮腿索引,在注册时使用
/* DJI电机的实例,此处仅保存指针,内存的分配将通过电机实例初始化时通过malloc()进行 */
static leg_obj_t leg_obj[2];

static void _leg_resolve_pos(leg_obj_t *leg)
{
    float l1 = leg->l1;
    float l2 = leg->l2;
    /* xdb = xd-xb; ydb = yd-yb; */
    float xd = leg->moto_distance + leg->l1 * arm_cos_f32(leg->phi4);
    float xb = l1 * arm_cos_f32(leg->phi1);
    float yd = leg->l1 * arm_sin_f32(leg->phi4);
    float yb = l1 * arm_sin_f32(leg->phi1);

    float A0 = 2 * l2 * (xd - xb);
    float B0 = 2 * l2 * (yd - yb);
    float C0 = (xd - xb)*(xd - xb) + (yd - yb)*(yd - yb);
    float phi2 = 2.0f * atan2f(B0 + sqrtf(A0*A0 + B0*B0 - C0*C0), (A0+C0));

    leg->U2 = phi2;

    /*计算B坐标*/
    leg->CoorB[0] = l1 * arm_cos_f32(leg->phi1)/* - leg->moto_distance_half*/;
    leg->CoorB[1] = l1 * arm_sin_f32(leg->phi1);
    /*计算C坐标*/
    leg->CoorC[0] = leg->CoorB[0] + l2 * arm_cos_f32(leg->U2);
    leg->CoorC[1] = leg->CoorB[1] + l2 * arm_sin_f32(leg->U2);
    /*计算D坐标*/
    leg->CoorD[0] = l1 * arm_cos_f32(leg->phi4) + leg->moto_distance;
    leg->CoorD[1] = l1 * arm_sin_f32(leg->phi4);
    /*计算u3*/
    leg->U3 = atan2f((yb - yd) + l2 * arm_sin_f32(phi2), (xb - xd) + l2 * arm_cos_f32(phi2));

    /*输出摆长摆角*/
    leg->PendulumRadian = atan2f(leg->CoorC[1],leg->CoorC[0] - leg->moto_distance_half);
    leg->PendulumLength = sqrtf((leg->CoorC[0] - leg->moto_distance_half)*(leg->CoorC[0] - leg->moto_distance_half) + leg->CoorC[1]*leg->CoorC[1]);
}

/**
 * @brief 求得腿部运动速度 [dl0; dphi0]
 * @param leg 腿部实例句柄
 * @param d_phi4 phi4的角速度，单位为rad/s
 * @param d_phi1 phi1的角速度，单位为rad/s
 */
static void _get_leg_spd(struct leg_obj *leg, float d_phi4, float d_phi1)
{
    const float lpfRatio = 0.5f; //低通滤波系数(新值的权重)
    float phi1 = leg->phi1;
    float phi4 = leg->phi4;
    float b_out_tmp;
    float out_tmp;
    float t10_tmp;
    float t12_tmp;
    float t2;
    float t21;
    float t22;
    float t23;
    float t24;
    float t28;
    float t3;
    float t32;
    float t4;
    float t44;
    float t47;
    float t48;
    float t5;
    float t52;
    float t53;
    float t59;
    float t60;
    float t61;
    float t70;
    float t71;
    float t76;
    /*     This function was generated by the Symbolic Math Toolbox version 9.2.
     */
    /*     26-Feb-2023 10:23:21 */
    t2 = cosf(phi1);
    t3 = cosf(phi4);
    t4 = sinf(phi1);
    t5 = sinf(phi4);
    t10_tmp = t2 / 20.0F;
    t12_tmp = t4 / 20.0F;
    t21 = t2 * 0.0105F;
    t22 = t3 * 0.0105F;
    t23 = t4 * 0.0105F;
    t24 = t5 * 0.0105F;
    t28 = t12_tmp - t5 / 20.0F;
    out_tmp = t3 / 20.0F - t10_tmp;
    t32 = t23 - t24;
    b_out_tmp = t22 - t21;
    t44 = t28 * t28 + (out_tmp + 0.06F) * (out_tmp + 0.06F);
    t47 = t2 * t28 / 10.0F + t4 * (out_tmp + 0.06F) / 10.0F;
    t48 = t3 * t28 / 10.0F + t5 * (out_tmp + 0.06F) / 10.0F;
    t52 = 1.0F / ((b_out_tmp + 0.0126F) + t44);
    t53 = t52 * t52;
    t59 = sqrtf((t32 * t32 + (b_out_tmp + 0.0126F) * (b_out_tmp + 0.0126F)) -
                t44 * t44);
    t60 = 1.0F / t59;
    t61 = (t24 - t23) + t59;
    t28 = atanf(t52 * t61) * 2.0F;
    t70 = cosf(t28);
    t71 = sinf(t28);
    t76 = 1.0F / (t53 * (t61 * t61) + 1.0F);
    t47 = (t23 + t47) * t53 * t61 +
          t52 * (t21 -
                 t60 *
                 ((t2 * t32 * 0.021F + t4 * (b_out_tmp + 0.0126F) * 0.021F) -
                  t44 * t47 * 2.0F) /
                 2.0F);
    t28 = (t24 + t48) * t53 * t61 +
          t52 * (t22 -
                 t60 *
                 ((t3 * t32 * 0.021F + t5 * (b_out_tmp + 0.0126F) * 0.021F) -
                  t44 * t48 * 2.0F) /
                 2.0F);
    t21 = t12_tmp + t71 * 0.105F;
    out_tmp = t10_tmp + t70 * 0.105F;
    t59 = t70 * t76;
    t23 = t59 * t28;
    t2 = t71 * t76;
    t4 = t2 * t28;
    t28 = -t10_tmp - t70 * 0.105F;
    t60 = (t28 + 0.03F) * (t28 + 0.03F);
    t61 = 1.0F / (t28 + 0.03F);
    t48 = 1.0F / sqrtf(t21 * t21 + (out_tmp - 0.03F) * (out_tmp - 0.03F));
    t52 = 1.0F / (t21 * t21 + t60);
    t53 = t21 * (1.0F / t60);
    t59 = t10_tmp - t59 * t47 * 0.21F;
    t28 = t12_tmp - t2 * t47 * 0.21F;

    leg->last_dl0 = leg->d_l0;
    leg->d_l0 =
            d_phi4 * t48 * (t21 * t23 * 0.42F - (out_tmp - 0.03F) * t4 * 0.42F) /
            2.0F +
            d_phi1 * t48 * (t21 * t59 * 2.0F - (out_tmp - 0.03F) * t28 * 2.0F) / 2.0F;
    leg->d_phi0 =
            d_phi4 * t60 * t52 * (t61 * (0.0F - t23 * 0.21F) + t53 * (t4 * 0.21F)) -
            d_phi1 * t60 * t52 * (t61 * t59 - t53 * t28);
    leg->dd_l0 = ((leg->d_l0 - leg->last_dl0) * 1000) * lpfRatio + leg->dd_l0 * (1 - lpfRatio);  // 用于计算离地检测
}

static int8_t _input_leg_angle(leg_obj_t *leg, float phi4, float phi1)
{
    leg->phi4 = phi4;
    leg->phi1 = phi1;

    if(phi4>leg->phi4_max)
    {leg->leg_state = LEG_ERROR;}
    else if(phi1<leg->phi1_min)
    {leg->leg_state = LEG_ERROR;}
    else
    {leg->leg_state = LEG_NORMAL;}

    return (uint8_t)leg->leg_state;
}

/*Leg motors*/
/*FT = [PendulumForce PendulumTorque]   Torque = [Motor3Torque(backmotor)  Motor2Torque(frontmotor)] */
static void _VMC_calculation(leg_obj_t *leg, float *FT, float *Tmotor)
{
    /*计算VMC*/
    volatile float q00,q01,q10,q11;
    /*中间变量*/
    volatile float sin32 = arm_sin_f32(leg->U3-leg->U2);
    volatile float sin12 = arm_sin_f32(leg->phi1 - leg->U2);
    volatile float sin34 = arm_sin_f32(leg->U3 - leg->phi4);


    q00 = leg->l1 * arm_sin_f32(leg->PendulumRadian - leg->U3) * sin12 / sin32;
    q01 = leg->l1 * arm_cos_f32(leg->PendulumRadian - leg->U3) * sin12 / (leg->PendulumLength *sin32);
    q10 = leg->l1 * arm_sin_f32(leg->PendulumRadian - leg->U2) * sin34 / sin32;
    q11 = leg->l1 * arm_cos_f32(leg->PendulumRadian - leg->U2) * sin34 / (leg->PendulumLength *sin32);

    /*矩阵乘法*/
    Tmotor[0] = q00*FT[0] + q01*FT[1];
    Tmotor[1] = q10*FT[0] + q11*FT[1];
}

/**
 * @brief 轮腿初始化,返回一个轮腿实例
 * @param config 轮腿配置
 * @return leg_obj_t* 轮腿实例指针
 */
leg_obj_t *leg_register(leg_config_t *config/* , void *control */)
{
    leg_obj[idx].l1 = config->l1;
    leg_obj[idx].l2 = config->l2;
    leg_obj[idx].moto_distance = config->moto_distance;
    leg_obj[idx].moto_distance_half = config->moto_distance / 2;
    leg_obj[idx].phi4_max = PI/2;
    leg_obj[idx].phi1_min = PI/2;
    leg_obj[idx].leg_state = LEG_ERROR;
    leg_obj[idx].PendulumRadian = PI/2;
    leg_obj[idx].resolve = _leg_resolve_pos;
    leg_obj[idx].get_leg_spd = _get_leg_spd;
    leg_obj[idx].VMC_cal = _VMC_calculation;
    leg_obj[idx].input_leg_angle = _input_leg_angle;

    return &leg_obj[idx++];
}

// 测试接口
/* void input(int argc,char** argv)  //(float phi4, float phi1) // 直接输入角度
{
    float phi1, phi4;
    sscanf(argv[1],"%f",&phi4);     //字符串转数字
    sscanf(argv[2],"%f",&phi1);     //字符串转数字
    _input_leg_angle(&leg_obj[0], phi4/180.f*PI, phi1/180.f*PI);
    leg_obj[0].resolve(&leg_obj[0]);
    rt_kprintf("PendulumLength = %f, PendulumRadian = %f\r\n", leg_obj[0].PendulumLength, leg_obj[0].PendulumRadian*180/PI);
    rt_kprintf("CoorC = [%f, %f], CoorB = [%f, %f], CoorD = [%f, %f]\r\n", leg_obj[0].CoorC[0], leg_obj[0].CoorC[1], leg_obj[0].CoorB[0], leg_obj[0].CoorB[1], leg_obj[0].CoorD[0], leg_obj[0].CoorD[1]);
    rt_kprintf("U2 = %f, U3 = %f\r\n", leg_obj[0].U2*180/PI, leg_obj[0].U3*180/PI);
}
MSH_CMD_EXPORT(input, leg test reslove input); */